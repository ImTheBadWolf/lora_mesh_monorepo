<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCF protocol</title>
    <link rel="stylesheet" href="web/style.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <script>
      const MAX_MESSAGE_LENGTH = 238;
      let WACK = false;
      let SENSOR_MESSAGES = true;
      let scrollToEnd = true;
      let shouldUpdate = true;

      let messagesMap = new Map();
      let sentMessages = new Map();
      let contactsMap = new Map();
      let sensorsMap = new Map();

      function scrolledEnd() {
        const messagesElement = document.getElementsByClassName("messages")[0];
        return Math.ceil(messagesElement.scrollTop + messagesElement.clientHeight) === messagesElement.scrollHeight
      }

      function isFailed(messageState) {
        return messageState === 'FAILED' || messageState === 'NAK'
      }
      function showStatusIcons(message) {
        return !!(!!message.state && !isFailed(message.state) && message.msg_type === 'WACK_TEXT')
      }
      function addressTranslation(address, messageType){
        if (messageType === 'SENSOR') {
          return sensorsMap.get(address) || address;
        }
        return contactsMap.get(address) || address;
      }

      function updateMessageList() {
        const sendButton = document.getElementById('sendBtn');
        const traceRouteButton = document.getElementById('tracerouteBtn');
        sendButton.disabled = false;
        traceRouteButton.disabled = false;

        if (!shouldUpdate) {
          return;
        }
        scrollToEnd = scrollToEnd || scrolledEnd();

        let messagesElement = document.getElementsByClassName("messages")[0];
        messagesElement.innerHTML = '';

        messagesMap = new Map([...messagesMap.entries()].sort((a, b) => a[1].order - b[1].order));

        messagesMap.forEach((message)=>{
          if (message.msg_type === 'SENSOR' && !SENSOR_MESSAGES) {
            return;
          }
          messagesElement.innerHTML = messagesElement.innerHTML + `
            <div class="message ${message.msg_type === 'SENSOR' ? 'sns-message' : ''}">
              ${(message.state && isFailed(message.state)) ? `<button class="fail-msg" onclick="resendMessage(${message.id})">
                <img class="fail-icon" src="web/icons/refresh-arrow.png" >
                <span>Message failed</span>
              </button>` : ''}
              <span class="message__header ${message.state ? 'my-header':''}">
                ${addressTranslation(message.from, message.msg_type)} ‚ü∂ ${addressTranslation(message.to, message.msg_type)}
              </span>
              <div class="message__content ${message.msg_type === 'SENSOR' ? 'sns-content':''} ${message.msg_type === 'TRACEROUTE' ? 'trc-content':''} ${message.state ? 'my-content':''} ${message.state && isFailed(message.state) ? 'failed':''}">
                ${message.payload}
              </div>
              ${showStatusIcons(message) ? (message.state === 'ACK' ? '<img class="icon" src="web/icons/check.png">' :'<img class="icon" src="web/icons/check_empty.png">') : ''}
            </div>
           `
          })

        if (scrollToEnd) {
          messagesElement.scroll({ top: messagesElement.scrollHeight, behavior: 'smooth' });
          scrollToEnd = false;
        }
        shouldUpdate = false;
      }

      function fillContactsSelect(){
        let contactsSelect = document.getElementById('contactsSelect');
        contactsMap.forEach((name, address)=>{
          if (name === 'YOU') {
            return;
          }
          contactsSelect.innerHTML += `<option value="${address}">${name}</option>`
        })
      }

      async function pullAddressBook() {
        return new Promise(function(resolve, reject) {
          let counter = 2;
          $.get("/api/contacts", function(data, status){
            if (status !== 'success') {
              reject();
            }
            const jsonData = JSON.parse(data);
            jsonData.contacts.forEach((contact)=>{
              if (!contactsMap.has(contact.address)) {
                contactsMap.set(contact.address, contact.name)
              }
            })
          });
          $.get("/api/sensors", function(data, status){
            if (status !== 'success') {
              reject();
            }
            const jsonData = JSON.parse(data);
            jsonData.sensors.forEach((sensor)=>{
              if (!sensorsMap.has(sensor.address)) {
                sensorsMap.set(sensor.address, sensor.name)
              }
            })
          });
          resolve();
        });
      }

      async function pullNewMessages() {
        let pages;
        return new Promise(async function(resolve, reject) {
          await $.get("/api/messages", function(data, status){
            if (status !== 'success') {
              reject();
            }
            const jsonData = JSON.parse(data);
            pages = jsonData.pages;
            jsonData.messages.forEach((message)=>{
              if (!messagesMap.has(message.id)) {
                messagesMap.set(message.id, message)
                shouldUpdate = true;
              }
              else {
                //Update message state
                const oldMessage = messagesMap.get(message.id);
                if (oldMessage.state !== message.state) {
                  messagesMap.set(message.id, {...oldMessage, state:message.state})
                  shouldUpdate = true;
                }
              }
            })
          });
          for (let i = 1; i < pages; i++) {
            await $.get(`/api/messages?page=${i}`, function(data, status){
              if (status !== 'success') {
                reject();
              }
              const jsonData = JSON.parse(data);
              jsonData.messages.forEach((message)=>{
                if (!messagesMap.has(message.id)) {
                  messagesMap.set(message.id, message)
                  shouldUpdate = true;
                }
                else {
                  //Update message state
                  const oldMessage = messagesMap.get(message.id);
                  if (oldMessage.state !== message.state) {
                    messagesMap.set(message.id, {...oldMessage, state:message.state})
                    shouldUpdate = true;
                  }
                }
              })
            });
          }
          updateMessageList();
          resolve();
        })
      }

      function handleToggleChange(e) {
        SENSOR_MESSAGES = e.target.checked;
        const snsMessages = document.querySelectorAll('.sns-message');
        snsMessages.forEach((message) => {
          if (e.target.checked) {
            message.style.display = 'flex';
          } else {
            message.style.display = 'none';
          }
        })
      }
      function handleSelectChange(e) {
          const addressInput = document.getElementById('addressInput');
          if (e.target.value === 'custom') {
            addressInput.disabled = false;
            addressInput.value = ""
          } else {
            addressInput.disabled = true;
            addressInput.value = e.target.value;
          }
      }
      function toggleWACK(e) {
        WACK = e.target.checked
      }

      function sendMessage() {
        const addressInput = document.getElementById('addressInput');
        const messageInput = document.getElementById('textArea');
        const maxHopInput = document.getElementById('maxHopInput');
        const prioritySelect = document.getElementById('prioritySelect');
        const sendButton = document.getElementById('sendBtn');
        const traceRouteButton = document.getElementById('tracerouteBtn');

        if (!addressInput.value.match(/^0x[0-9a-fA-F]{4}$/)) {
          alert('Invalid address');
          return;
        }

        if(!maxHopInput.value.match(/^[0-9]+$/) || maxHopInput.value < 1 || maxHopInput.value > 255) {
          alert('Invalid max hop value');
          return;
        }

        if (messageInput.value.length > MAX_MESSAGE_LENGTH || messageInput.value.length === 0) {
          alert('Message is too long or empty');
          return;
        }

        const message = {
          'destination': addressInput.value,
          'message': messageInput.value,
          'max_hop': maxHopInput.value,
          'priority': prioritySelect.value,
          'wack': WACK
        }

        sendButton.disabled = true;
        traceRouteButton.disabled = true;
        $.post("/api/send_text_message", JSON.stringify(message));
        messageInput.value = '';
        scrollToEnd = true;
      }
      function traceRoute() {
        const addressInput = document.getElementById('addressInput');
        const maxHopInput = document.getElementById('maxHopInput');
        const prioritySelect = document.getElementById('prioritySelect');
        const sendButton = document.getElementById('sendBtn');
        const traceRouteButton = document.getElementById('tracerouteBtn');

         if (!addressInput.value.match(/^0x[0-9a-fA-F]{4}$/)) {
          alert('Invalid address');
          return;
        }

        if(!maxHopInput.value.match(/^[0-9]+$/) || maxHopInput.value < 1 || maxHopInput.value > 255) {
          alert('Invalid max hop value');
          return;
        }

        const message = {
          'destination': addressInput.value,
          'max_hop': maxHopInput.value,
          'priority': prioritySelect.value,
        }

        sendButton.disabled = true;
        traceRouteButton.disabled = true;
        $.post("/api/traceroute", JSON.stringify(message));
        scrollToEnd = true;
      }
      function resendMessage(messageId){
        //TODO resend message with the same id
        //TODO post to /resend_message, for testing purposes server will just set state to ACK for that message (or REBROADCASTED and it will wait for ACK)
        const message = sentMessages.get(messageId);
        const sendButton = document.getElementById('sendBtn');
        const traceRouteButton = document.getElementById('tracerouteBtn');
        sendButton.disabled = true;
        traceRouteButton.disabled = true;
        $.post("/api/resend_message", JSON.stringify({'message_id': messageId}));
        scrollToEnd = true;
      }

      $(document).ready(async function(){
        await pullAddressBook();
        await pullNewMessages();
        fillContactsSelect();
        setInterval(pullNewMessages, 5000);
      });
    </script>
  </head>
  <body>
    <div class="menu">
      <ul>
        <li><a href="#" class="underlined">HOME</a></li>
        <li><a href="/sensors">SENSORS</a></li>
        <li><a href="/contacts">CONTACTS</a></li>
        <li><a href="/config">CONFIG</a></li>
      </ul>
    </div>
    <div class="content">
      <div class="toggle">
        <p class="info-label">Show sensor messages</p>
        <label class="switch">
          <input type="checkbox" onchange="handleToggleChange(event)" checked>
          <span class="slider round"></span>
        </label>
      </div>
      <div class="messages">
      </div>
      <div class="new_msg">
        <div class="toggle">
          <p class="info-label">Send message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receive ACK:</p>
          <label class="switch">
            <input type="checkbox" onchange="toggleWACK(event)">
            <span class="slider round"></span>
          </label>
        </div>
        <textarea id="textArea" maxlength="238"></textarea>
        <div class="confirm">
          <div>
            <span class="info-label">Max Hop:</span>
            <input id="maxHopInput" type="number" min="1" max="255" value="3">
            <span class="info-label">Priority:</span>
            <select id="prioritySelect">
              <option value="0">Normal</option>
              <option value="1">High</option>
            </select>
          </div>
          <div>
            <span class="info-label">Destination:</span>
            <select id="contactsSelect" onchange="handleSelectChange(event)">
              <option value="custom">Custom</option>
            </select>
            <input id="addressInput" type="text" maxlength="6">
            <button id="sendBtn" class="btn" onclick="sendMessage()">SEND</button>
          </div>
        </div>
        <button id="tracerouteBtn" class="btn" onclick="traceRoute()">TRACEROUTE</button>
      </div>
    </div>
  </body>
</html>